name: Self-Healing Infrastructure CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        default: 'dev'
        type: choice
        options: [dev, staging, prod]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/self-healing-controller
  IMAGE_TAG: ${{ github.sha }}

# ------------------------------------------------
jobs:
  # 1. Quality & Tests for Python + Terraform
  ci:
    name: Lint & Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        tool: [python, terraform]
    steps:
      - uses: actions/checkout@v4

      - name: Cache pip dependencies
        if: matrix.tool == 'python'
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('kubernetes/self-healing/requirements*.txt') }}
      
      - name: Cache Terraform plugins
        if: matrix.tool == 'terraform'
        uses: actions/cache@v3
        with:
          path: ~/.terraform.d/plugin-cache
          key: ${{ runner.os }}-tf-plugins-${{ hashFiles('terraform/**/*.tf') }}

      - name: Setup Python
        if: matrix.tool == 'python'
        uses: actions/setup-python@v4
        with: 
          python-version: '3.9'
      - name: Setup Terraform
        if: matrix.tool == 'terraform'
        uses: hashicorp/setup-terraform@v2
        with: 
          terraform_version: '1.0.11'

      - name: Install dependencies
        if: matrix.tool == 'python'
        run: |
          pip install --upgrade pip
          # Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ runtime Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð°
          pip install -r kubernetes/self-healing/requirements.txt
          # Ð—Ð°Ñ‚ÐµÐ¼ dev-Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¾Ð² Ð¸ Ð»Ð¸Ð½Ñ‚Ð¸Ð½Ð³Ð°
          pip install -r kubernetes/self-healing/requirements-dev.txt

      - name: Lint with Black & isort & Flake8
        if: matrix.tool == 'python'
        run: |
          black --check kubernetes/self-healing/
          isort --check-only kubernetes/self-healing/
          flake8 kubernetes/self-healing/ --max-line-length=120

      - name: Run unit tests with coverage
        if: matrix.tool == 'python'
        working-directory: kubernetes/self-healing
        run: |
          pytest \
            --maxfail=1 \
            --disable-warnings \
            -v \
            --cov=. \
            --cov-report=xml \
            --cov-report=html
      
      - name: Upload coverage report
        if: matrix.tool == 'python'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: kubernetes/self-healing/htmlcov/
      - name: Configure Terraform plugin cache
        if: matrix.tool == 'terraform'
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo "TF_PLUGIN_CACHE_DIR=$HOME/.terraform.d/plugin-cache" >> $GITHUB_ENV

      - name: Terraform Validate
        if: matrix.tool == 'terraform'
        run: |
          cd terraform
          terraform init
          terraform validate

  # 2. Build & Push Docker
  build-push:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: ci
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - uses: docker/build-push-action@v5
        with:
          context: ./kubernetes/self-healing
          file: ./kubernetes/self-healing/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}

  # 3. Infrastructure: Deploy with Terraform
  infra-deploy:
    name: Terraform Deploy
    runs-on: ubuntu-latest
    needs: build-push
    steps:
      - uses: actions/checkout@v4

      # 3.1 Setup Kubernetes
      - name: Setup Minikube
        uses: ./.github/actions/setup-minikube

      # 3.2 Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: '1.0.11'

      # 3.3 Cache Terraform plugins
      - uses: actions/cache@v3
        with:
          path: ~/.terraform.d/plugin-cache
          key: ${{ runner.os }}-tf-plugins-${{ hashFiles('terraform/**/*.tf') }}

      # 3.4 Configure Terraform plugin cache
      - name: Configure Terraform plugin cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo "TF_PLUGIN_CACHE_DIR=$HOME/.terraform.d/plugin-cache" >> $GITHUB_ENV

      # 3.5 Deploy infrastructure
      - name: Terraform Init & Apply
        working-directory: terraform
        run: |
          terraform init
          terraform plan -var="ci_cd_mode=false" -out=tfplan
          terraform apply -auto-approve tfplan

      # 3.6 Wait for deployments to be ready
      - name: Wait for Self-Healing Controller to be ready
        run: |
          echo "ðŸš€ Waiting for Self-Healing Controller to be ready..."
          kubectl rollout status deployment/self-healing-controller \
            -n self-healing \
            --timeout=60s
      
      - name: Wait for test-app to be ready
        run: |
          echo "ðŸš€ Waiting for test-app to be ready..."
          kubectl rollout status deployment/test-app \
            -n test-app \
            --timeout=60s
      
      # 3.7 Debug test-app on failure
      - name: Debug test-app (on failure)
        if: failure()
        run: |
          echo "=== Pods in test-app namespace ==="
          kubectl get pods -n test-app -o wide
          
          echo "=== Describe Deployment ==="
          kubectl describe deployment/test-app -n test-app
          
          echo "=== Describe Pods ==="
          kubectl describe pods -l app=test-app -n test-app
          
          echo "=== Logs from test-app pods ==="
          kubectl logs -l app=test-app -n test-app --tail=50 || echo "No logs available"
          
          echo "=== Events in test-app namespace ==="
          kubectl get events -n test-app --sort-by='.lastTimestamp' | tail -20

      # 3.8 Wait for metrics-server
      - name: Wait for metrics-server
        run: |
          echo "ðŸš€ Waiting for metrics-server to be ready..."
          kubectl wait --for=condition=available deployment/metrics-server -n kube-system --timeout=60s || echo "Metrics-server not ready yet"

      # 3.9 Basic smoke test
      - name: Smoke Test
        run: |
          kubectl get ns self-healing monitoring chaos-engineering
          kubectl get pods --all-namespaces

  # 4. Self-Healing Controller Tests
  self-healing-test:
    name: Self-Healing Controller Tests
    runs-on: ubuntu-latest
    needs: infra-deploy
    steps:
      - uses: actions/checkout@v4
      - name: Setup Minikube
        uses: ./.github/actions/setup-minikube

      - name: Load Docker image
        run: |
          cd kubernetes/self-healing
          docker build -t self-healing-controller:latest .
          minikube image load self-healing-controller:latest

      - name: Wait for components to be ready
        run: |
          echo "ðŸš€ Waiting for Self-Healing Controller to roll out..."
          kubectl rollout status deployment/self-healing-controller -n self-healing --timeout=120s
          
          echo "ðŸš€ Waiting for test-app to roll out..."
          kubectl rollout status deployment/test-app -n test-app --timeout=120s

      - name: Test Self-Healing Controller health
        run: |
          # Start port-forward in background
          kubectl port-forward -n self-healing svc/self-healing-controller 8081:8080 &
          PF_PID=$!
          sleep 10

          # Test health endpoint
          curl -f http://localhost:8081/health || exit 1
          curl -f http://localhost:8081/metrics || exit 1

          kill $PF_PID

      - name: Test pod failure recovery
        run: |
          echo "Creating a failing pod to test self-healing..."
          kubectl run test-healing-pod --image=busybox --command -- /bin/sh -c "sleep 3 && exit 1" -n test-app
          sleep 15

          pod_status=$(kubectl get pod test-healing-pod -n test-app -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")
          if [ "$pod_status" = "NotFound" ]; then
            echo "âœ… Self-Healing Controller successfully detected and handled failing pod"
          else
            echo "âŒ Self-Healing Controller did not handle failing pod (status: $pod_status)"
            exit 1
          fi

          kubectl delete pod test-healing-pod -n test-app --ignore-not-found=true

  # 5. Monitoring Tests
  monitoring-test:
    name: Monitoring Tests
    runs-on: ubuntu-latest
    needs: infra-deploy
    steps:
      - uses: actions/checkout@v4
      - name: Setup Minikube
        uses: ./.github/actions/setup-minikube

      - name: Load Docker image
        run: |
          cd kubernetes/self-healing
          docker build -t self-healing-controller:latest .
          minikube image load self-healing-controller:latest

      - name: Wait for monitoring components
        run: |
          echo "ðŸš€ Waiting for Prometheus stack to roll out..."
          # Ð–Ð´ÐµÐ¼ Ð³Ð¾Ñ‚Ð¾Ð²Ð½Ð¾ÑÑ‚Ð¸ Prometheus stack Ñ‡ÐµÑ€ÐµÐ· Helm release
          kubectl wait --for=condition=available deployment/prometheus-kube-prometheus-prometheus -n monitoring --timeout=300s || echo "Prometheus deployment not found, continuing..."
          kubectl wait --for=condition=available deployment/prometheus-grafana -n monitoring --timeout=300s || echo "Grafana deployment not found, continuing..."

      - name: Test Prometheus connectivity
        run: |
          kubectl port-forward -n monitoring svc/prometheus-kube-prometheus-prometheus 9090:9090 &
          PF_PID=$!
          sleep 10

          curl -f http://localhost:9090/api/v1/query?query=up || exit 1
          curl -f "http://localhost:9090/api/v1/query?query=up{job=\"self-healing-controller\"}" || echo "No self-healing metrics yet"

          kill $PF_PID

      - name: Test Grafana connectivity
        run: |
          kubectl port-forward -n monitoring svc/prometheus-grafana 3000:80 &
          PF_PID=$!
          sleep 10

          curl -f http://localhost:3000/api/health || exit 1

          kill $PF_PID

  # 6. Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [self-healing-test, monitoring-test]
    steps:
      - uses: actions/checkout@v4
      - name: Setup Minikube
        uses: ./.github/actions/setup-minikube

      - name: Test Kured integration
        run: |
          kubectl get pods -n kured | grep Running
          kubectl describe daemonset kured -n kured

      - name: Test monitoring alerts
        run: |
          kubectl get prometheusrules -n monitoring || echo "No PrometheusRules found"
          kubectl get configmap -n monitoring | grep alertmanager || echo "No Alertmanager config found"

      - name: Test test application
        run: |
          kubectl get pods -n test-app | grep Running
          kubectl port-forward -n test-app svc/test-app 8080:80 &
          PF_PID=$!
          sleep 10
          curl -f http://localhost:8080 || echo "Test app not accessible"
          kill $PF_PID

  # 7. Performance Tests
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: integration-tests
    steps:
      - uses: actions/checkout@v4
      - name: Setup Minikube
        uses: ./.github/actions/setup-minikube

      - name: Test resource limits
        run: |
          kubectl describe nodes
          kubectl top nodes || echo "Metrics server not available"

      - name: Test scalability
        run: |
          kubectl scale deployment test-app -n test-app --replicas=5
          kubectl wait --for=condition=available deployment/test-app -n test-app --timeout=300s

          running_pods=$(kubectl get pods -n test-app | grep Running | wc -l)
          echo "Running pods: $running_pods"

          if [ "$running_pods" -ge 3 ]; then
            echo "âœ… Scaling test passed"
          else
            echo "âŒ Scaling test failed"
            exit 1
          fi

      - name: Test multiple pod failures
        run: |
          echo "Testing multiple pod failures..."

          for i in {1..3}; do
            kubectl run test-fail-$i --image=busybox --command -- /bin/sh -c "sleep 2 && exit 1" -n test-app
          done

          sleep 20

          remaining_pods=$(kubectl get pods -n test-app | grep test-fail | wc -l)
          echo "Remaining test pods: $remaining_pods"

          if [ "$remaining_pods" -eq 0 ]; then
            echo "âœ… Multiple pod failure test passed"
          else
            echo "âŒ Multiple pod failure test failed"
            exit 1
          fi

  # 8. Cleanup & Report
  cleanup:
    name: Cleanup & Report
    runs-on: ubuntu-latest
    needs: [performance-tests]
    if: always()
    steps:
      - uses: actions/checkout@v4
      - name: Setup Minikube
        uses: ./.github/actions/setup-minikube

      - name: Collect logs
        run: |
          kubectl get pods --all-namespaces >> system-report.txt
          kubectl logs -n self-healing deployment/self-healing-controller --tail=50 >> system-report.txt
          kubectl get events --all-namespaces --sort-by='.lastTimestamp' | tail -20 >> system-report.txt

      - name: Upload report
        uses: actions/upload-artifact@v4
        with:
          name: system-report
          path: system-report.txt

      - name: Cleanup test resources
        if: always()
        run: |
          kubectl delete pod -l test=true -n test-app --ignore-not-found=true
          kubectl delete pod test-healing-pod -n test-app --ignore-not-found=true
          kubectl delete pod test-crash-pod -n test-app --ignore-not-found=true
